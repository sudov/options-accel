

================================================================
== Vivado HLS Report for 'black_scholes_init_by_array'
================================================================
* Date:           Sat Nov 22 14:31:22 2014

* Version:        2014.2 (Build 932637 on Wed Jun 11 12:38:34 PM 2014)
* Project:        hls.prj
* Solution:       solution1
* Product family: zynq zynq_fpv6 
* Target device:  xc7z020clg484-1


================================================================
== Performance Estimates
================================================================
+ Timing (ns): 
    * Summary: 
    +---------+-------+----------+------------+
    |  Clock  | Target| Estimated| Uncertainty|
    +---------+-------+----------+------------+
    |default  |  10.00|      8.52|        1.25|
    +---------+-------+----------+------------+

+ Latency (clock cycles): 
    * Summary: 
    +-------+-------+-------+-------+---------+
    |    Latency    |    Interval   | Pipeline|
    |  min  |  max  |  min  |  max  |   Type  |
    +-------+-------+-------+-------+---------+
    |  18704|  19951|  18704|  19951|   none  |
    +-------+-------+-------+-------+---------+

    + Detail: 
        * Instance: 
        N/A

        * Loop: 
        +----------+------+------+----------+-----------+-----------+------+----------+
        |          |   Latency   | Iteration|  Initiation Interval  | Trip |          |
        | Loop Name|  min |  max |  Latency |  achieved |   target  | Count| Pipelined|
        +----------+------+------+----------+-----------+-----------+------+----------+
        |- Loop 1  |  5607|  5607|         9|          -|          -|   623|    no    |
        |- Loop 2  |  6864|  7488|  11 ~ 12 |          -|          -|   624|    no    |
        |- Loop 3  |  6230|  6853|  10 ~ 11 |          -|          -|   623|    no    |
        +----------+------+------+----------+-----------+-----------+------+----------+



================================================================
== Utilization Estimates
================================================================
* Summary: 
+-----------------+---------+-------+--------+-------+
|       Name      | BRAM_18K| DSP48E|   FF   |  LUT  |
+-----------------+---------+-------+--------+-------+
|Expression       |        -|      -|       -|      -|
|FIFO             |        -|      -|       -|      -|
|Instance         |        -|      -|       -|      -|
|Memory           |        -|      -|       -|      -|
|Multiplexer      |        -|      -|       -|      -|
|Register         |        -|      -|       -|      -|
+-----------------+---------+-------+--------+-------+
|Total            |        0|      0|       0|      0|
+-----------------+---------+-------+--------+-------+
|Available        |      280|    220|  106400|  53200|
+-----------------+---------+-------+--------+-------+
|Utilization (%)  |        0|      0|       0|      0|
+-----------------+---------+-------+--------+-------+

+ Detail: 
    * Instance: 
    N/A

    * Memory: 
    N/A

    * FIFO: 
    N/A

    * Expression: 
    N/A

    * Multiplexer: 
    N/A

    * Register: 
    N/A



================================================================
== Interface
================================================================
* Summary: 
N/A

============================================================
+ Verbose Summary: Synthesis Manager
============================================================
InlineROM: 1
ExposeGlobal: 0
============================================================
+ Verbose Summary: CDFG Model
============================================================
IsTopModel: 0
ResetActiveHigh: 1
IsCombinational: 0
IsDatapathOnly: 0
HasWiredReturn: 1
HasMFsm: 0
HasVarLatency: 1
IsPipeline: 0
IsRtlPipelined: 0
IsInstanceOverlapped: 0
IsDontTouch: 0
HasImplIP: 0
IsGatedGlobalClock: 0


============================================================
+ Verbose Summary: Schedule
============================================================
* Number of FSM states: 33
* Pipeline: 0
* Dataflow Pipeline: 0

* FSM state transitions: 
1 --> 
	2  / true
2 --> 
	3  / (!exitcond_i)
	11  / (exitcond_i)
3 --> 
	4  / true
4 --> 
	5  / true
5 --> 
	6  / true
6 --> 
	7  / true
7 --> 
	8  / true
8 --> 
	9  / true
9 --> 
	10  / true
10 --> 
	2  / true
11 --> 
	12  / (!tmp)
	23  / (tmp)
12 --> 
	13  / true
13 --> 
	14  / true
14 --> 
	15  / true
15 --> 
	16  / true
16 --> 
	17  / true
17 --> 
	18  / true
18 --> 
	19  / true
19 --> 
	20  / (tmp_21)
	21  / (!tmp_21)
20 --> 
	21  / true
21 --> 
	22  / true
22 --> 
	11  / true
23 --> 
	24  / (!tmp_3)
24 --> 
	25  / true
25 --> 
	26  / true
26 --> 
	27  / true
27 --> 
	28  / true
28 --> 
	29  / true
29 --> 
	30  / true
30 --> 
	31  / true
31 --> 
	32  / (tmp_22)
	33  / (!tmp_22)
32 --> 
	33  / true
33 --> 
	23  / true
* FSM state operations: 

 <State 1>: 2.39ns
ST_1: stg_34 [1/1] 2.39ns
:0  store i64 19650218, i64* getelementptr inbounds ([624 x i64]* @mt, i64 0, i64 0), align 16

ST_1: stg_35 [1/1] 1.39ns
:1  br label %1


 <State 2>: 4.23ns
ST_2: tmp_1_i [1/1] 0.00ns
:0  %tmp_1_i = phi i10 [ 1, %0 ], [ %tmp_2_i, %2 ]

ST_2: tmp_1_i_cast [1/1] 0.00ns
:1  %tmp_1_i_cast = zext i10 %tmp_1_i to i32

ST_2: stg_38 [1/1] 0.00ns
:2  store i32 %tmp_1_i_cast, i32* @mti, align 4

ST_2: exitcond_i [1/1] 2.07ns
:3  %exitcond_i = icmp eq i10 %tmp_1_i, -400

ST_2: empty [1/1] 0.00ns
:4  %empty = call i32 (...)* @_ssdm_op_SpecLoopTripCount(i64 623, i64 623, i64 623) nounwind

ST_2: stg_41 [1/1] 1.57ns
:5  br i1 %exitcond_i, label %init_genrand.exit, label %2

ST_2: tmp_3_i [1/1] 1.84ns
:0  %tmp_3_i = add i10 %tmp_1_i, -1

ST_2: tmp_4_i [1/1] 0.00ns
:1  %tmp_4_i = zext i10 %tmp_3_i to i64

ST_2: mt_addr_1 [1/1] 0.00ns
:2  %mt_addr_1 = getelementptr inbounds [624 x i64]* @mt, i64 0, i64 %tmp_4_i

ST_2: mt_load_6 [2/2] 2.39ns
:3  %mt_load_6 = load i64* %mt_addr_1, align 8


 <State 3>: 3.76ns
ST_3: mt_load_6 [1/2] 2.39ns
:3  %mt_load_6 = load i64* %mt_addr_1, align 8

ST_3: tmp_1 [1/1] 0.00ns
:4  %tmp_1 = call i32 @_ssdm_op_PartSelect.i32.i64.i32.i32(i64 %mt_load_6, i32 30, i32 61)

ST_3: tmp_17 [1/1] 0.00ns
:5  %tmp_17 = trunc i64 %mt_load_6 to i32

ST_3: tmp_18 [1/1] 1.37ns
:6  %tmp_18 = xor i32 %tmp_1, %tmp_17


 <State 4>: 6.08ns
ST_4: tmp_16 [6/6] 6.08ns
:8  %tmp_16 = mul i32 %tmp_18, 1812433253


 <State 5>: 6.08ns
ST_5: tmp_16 [5/6] 6.08ns
:8  %tmp_16 = mul i32 %tmp_18, 1812433253


 <State 6>: 6.08ns
ST_6: tmp_16 [4/6] 6.08ns
:8  %tmp_16 = mul i32 %tmp_18, 1812433253


 <State 7>: 6.08ns
ST_7: tmp_16 [3/6] 6.08ns
:8  %tmp_16 = mul i32 %tmp_18, 1812433253


 <State 8>: 6.08ns
ST_8: tmp_16 [2/6] 6.08ns
:8  %tmp_16 = mul i32 %tmp_18, 1812433253


 <State 9>: 8.52ns
ST_9: tmp_16 [1/6] 6.08ns
:8  %tmp_16 = mul i32 %tmp_18, 1812433253

ST_9: tmp_9_i_cast [1/1] 2.44ns
:9  %tmp_9_i_cast = add i32 %tmp_16, %tmp_1_i_cast


 <State 10>: 2.39ns
ST_10: tmp_8_i [1/1] 0.00ns
:7  %tmp_8_i = zext i10 %tmp_1_i to i64

ST_10: mt_addr_5 [1/1] 0.00ns
:10  %mt_addr_5 = getelementptr inbounds [624 x i64]* @mt, i64 0, i64 %tmp_8_i

ST_10: tmp_i_cast [1/1] 0.00ns
:11  %tmp_i_cast = zext i32 %tmp_9_i_cast to i64

ST_10: stg_60 [1/1] 2.39ns
:12  store i64 %tmp_i_cast, i64* %mt_addr_5, align 8

ST_10: tmp_2_i [1/1] 1.84ns
:13  %tmp_2_i = add i10 %tmp_1_i, 1

ST_10: stg_62 [1/1] 0.00ns
:14  br label %1


 <State 11>: 4.83ns
ST_11: i [1/1] 0.00ns
init_genrand.exit:0  %i = phi i32 [ %i_1, %._crit_edge ], [ 1, %1 ]

ST_11: j [1/1] 0.00ns
init_genrand.exit:1  %j = phi i32 [ %p_s, %._crit_edge ], [ 0, %1 ]

ST_11: k [1/1] 0.00ns
init_genrand.exit:2  %k = phi i10 [ %k_2, %._crit_edge ], [ -400, %1 ]

ST_11: tmp [1/1] 2.07ns
init_genrand.exit:3  %tmp = icmp eq i10 %k, 0

ST_11: empty_98 [1/1] 0.00ns
init_genrand.exit:4  %empty_98 = call i32 (...)* @_ssdm_op_SpecLoopTripCount(i64 624, i64 624, i64 624) nounwind

ST_11: stg_68 [1/1] 1.57ns
init_genrand.exit:5  br i1 %tmp, label %.preheader, label %_ifconv

ST_11: tmp_4 [1/1] 2.44ns
_ifconv:3  %tmp_4 = add nsw i32 %i, -1

ST_11: tmp_5 [1/1] 0.00ns
_ifconv:4  %tmp_5 = sext i32 %tmp_4 to i64

ST_11: mt_addr_2 [1/1] 0.00ns
_ifconv:5  %mt_addr_2 = getelementptr inbounds [624 x i64]* @mt, i64 0, i64 %tmp_5

ST_11: mt_load_1 [2/2] 2.39ns
_ifconv:6  %mt_load_1 = load i64* %mt_addr_2, align 8


 <State 12>: 3.76ns
ST_12: mt_load_1 [1/2] 2.39ns
_ifconv:6  %mt_load_1 = load i64* %mt_addr_2, align 8

ST_12: tmp_6 [1/1] 0.00ns
_ifconv:7  %tmp_6 = call i34 @_ssdm_op_PartSelect.i34.i64.i32.i32(i64 %mt_load_1, i32 30, i32 63)

ST_12: tmp_23 [1/1] 0.00ns
_ifconv:8  %tmp_23 = zext i34 %tmp_6 to i64

ST_12: tmp_7 [1/1] 1.37ns
_ifconv:9  %tmp_7 = xor i64 %tmp_23, %mt_load_1


 <State 13>: 6.08ns
ST_13: tmp_8 [6/6] 6.08ns
_ifconv:10  %tmp_8 = mul i64 %tmp_7, 1664525


 <State 14>: 6.08ns
ST_14: tmp_8 [5/6] 6.08ns
_ifconv:10  %tmp_8 = mul i64 %tmp_7, 1664525


 <State 15>: 6.08ns
ST_15: tmp_8 [4/6] 6.08ns
_ifconv:10  %tmp_8 = mul i64 %tmp_7, 1664525


 <State 16>: 6.08ns
ST_16: tmp_8 [3/6] 6.08ns
_ifconv:10  %tmp_8 = mul i64 %tmp_7, 1664525


 <State 17>: 6.08ns
ST_17: tmp_s [1/1] 0.00ns
_ifconv:0  %tmp_s = sext i32 %i to i64

ST_17: mt_addr [1/1] 0.00ns
_ifconv:1  %mt_addr = getelementptr inbounds [624 x i64]* @mt, i64 0, i64 %tmp_s

ST_17: mt_load [2/2] 2.39ns
_ifconv:2  %mt_load = load i64* %mt_addr, align 8

ST_17: tmp_8 [2/6] 6.08ns
_ifconv:10  %tmp_8 = mul i64 %tmp_7, 1664525


 <State 18>: 7.45ns
ST_18: mt_load [1/2] 2.39ns
_ifconv:2  %mt_load = load i64* %mt_addr, align 8

ST_18: tmp_8 [1/6] 6.08ns
_ifconv:10  %tmp_8 = mul i64 %tmp_7, 1664525

ST_18: tmp_9 [1/1] 1.37ns
_ifconv:11  %tmp_9 = xor i64 %tmp_8, %mt_load

ST_18: tmp_25 [1/1] 0.00ns
_ifconv:20  %tmp_25 = trunc i64 %tmp_9 to i32


 <State 19>: 8.46ns
ST_19: tmp_24 [1/1] 0.00ns
_ifconv:12  %tmp_24 = trunc i32 %j to i2

ST_19: sel_tmp [1/1] 1.36ns
_ifconv:13  %sel_tmp = icmp eq i2 %tmp_24, 1

ST_19: sel_tmp2 [1/1] 1.36ns
_ifconv:14  %sel_tmp2 = icmp eq i2 %tmp_24, -2

ST_19: sel_tmp4 [1/1] 1.36ns
_ifconv:15  %sel_tmp4 = icmp eq i2 %tmp_24, 0

ST_19: newSel_cast_cast [1/1] 1.37ns
_ifconv:16  %newSel_cast_cast = select i1 %sel_tmp4, i11 291, i11 837

ST_19: or_cond [1/1] 1.37ns
_ifconv:17  %or_cond = or i1 %sel_tmp4, %sel_tmp2

ST_19: newSel7 [1/1] 1.37ns
_ifconv:18  %newSel7 = select i1 %sel_tmp, i11 564, i11 -938

ST_19: newSel9 [1/1] 1.37ns
_ifconv:19  %newSel9 = select i1 %or_cond, i11 %newSel_cast_cast, i11 %newSel7

ST_19: tmp_19 [1/1] 1.97ns
_ifconv:21  %tmp_19 = add i32 %tmp_25, %j

ST_19: tmp_20 [1/1] 0.00ns
_ifconv:22  %tmp_20 = zext i11 %newSel9 to i32

ST_19: tmp_19_cast [1/1] 1.97ns
_ifconv:23  %tmp_19_cast = add i32 %tmp_19, %tmp_20

ST_19: tmp_20_cast [1/1] 0.00ns
_ifconv:24  %tmp_20_cast = zext i32 %tmp_19_cast to i64

ST_19: stg_101 [1/1] 2.39ns
_ifconv:25  store i64 %tmp_20_cast, i64* %mt_addr, align 8

ST_19: i_4 [1/1] 2.44ns
_ifconv:26  %i_4 = add nsw i32 %i, 1

ST_19: j_1 [1/1] 2.44ns
_ifconv:27  %j_1 = add nsw i32 %j, 1

ST_19: tmp_21 [1/1] 2.52ns
_ifconv:28  %tmp_21 = icmp sgt i32 %i_4, 623

ST_19: stg_105 [1/1] 1.57ns
_ifconv:29  br i1 %tmp_21, label %3, label %._crit_edge


 <State 20>: 2.39ns
ST_20: mt_load_2 [2/2] 2.39ns
:0  %mt_load_2 = load i64* getelementptr inbounds ([624 x i64]* @mt, i64 0, i64 623), align 8


 <State 21>: 4.78ns
ST_21: mt_load_2 [1/2] 2.39ns
:0  %mt_load_2 = load i64* getelementptr inbounds ([624 x i64]* @mt, i64 0, i64 623), align 8

ST_21: stg_108 [1/1] 2.39ns
:1  store i64 %mt_load_2, i64* getelementptr inbounds ([624 x i64]* @mt, i64 0, i64 0), align 16

ST_21: stg_109 [1/1] 1.57ns
:2  br label %._crit_edge

ST_21: tmp_28 [1/1] 0.00ns
._crit_edge:1  %tmp_28 = call i30 @_ssdm_op_PartSelect.i30.i32.i32.i32(i32 %j_1, i32 2, i32 31)

ST_21: icmp [1/1] 2.49ns
._crit_edge:2  %icmp = icmp slt i30 %tmp_28, 1

ST_21: p_s [1/1] 1.37ns
._crit_edge:3  %p_s = select i1 %icmp, i32 %j_1, i32 0

ST_21: k_2 [1/1] 1.84ns
._crit_edge:4  %k_2 = add i10 %k, -1


 <State 22>: 0.00ns
ST_22: i_1 [1/1] 0.00ns
._crit_edge:0  %i_1 = phi i32 [ 1, %3 ], [ %i_4, %_ifconv ]

ST_22: stg_115 [1/1] 0.00ns
._crit_edge:5  br label %init_genrand.exit


 <State 23>: 4.83ns
ST_23: i_2 [1/1] 0.00ns
.preheader:0  %i_2 = phi i32 [ %i_3, %._crit_edge1 ], [ %i, %init_genrand.exit ]

ST_23: k_1 [1/1] 0.00ns
.preheader:1  %k_1 = phi i10 [ %k_3, %._crit_edge1 ], [ -401, %init_genrand.exit ]

ST_23: tmp_3 [1/1] 2.07ns
.preheader:2  %tmp_3 = icmp eq i10 %k_1, 0

ST_23: empty_99 [1/1] 0.00ns
.preheader:3  %empty_99 = call i32 (...)* @_ssdm_op_SpecLoopTripCount(i64 623, i64 623, i64 623) nounwind

ST_23: stg_120 [1/1] 0.00ns
.preheader:4  br i1 %tmp_3, label %6, label %4

ST_23: tmp_10 [1/1] 2.44ns
:3  %tmp_10 = add nsw i32 %i_2, -1

ST_23: tmp_11 [1/1] 0.00ns
:4  %tmp_11 = sext i32 %tmp_10 to i64

ST_23: mt_addr_4 [1/1] 0.00ns
:5  %mt_addr_4 = getelementptr inbounds [624 x i64]* @mt, i64 0, i64 %tmp_11

ST_23: mt_load_4 [2/2] 2.39ns
:6  %mt_load_4 = load i64* %mt_addr_4, align 8

ST_23: stg_125 [1/1] 2.39ns
:0  store i64 2147483648, i64* getelementptr inbounds ([624 x i64]* @mt, i64 0, i64 0), align 16

ST_23: stg_126 [1/1] 0.00ns
:1  ret void


 <State 24>: 3.76ns
ST_24: mt_load_4 [1/2] 2.39ns
:6  %mt_load_4 = load i64* %mt_addr_4, align 8

ST_24: tmp_12 [1/1] 0.00ns
:7  %tmp_12 = call i34 @_ssdm_op_PartSelect.i34.i64.i32.i32(i64 %mt_load_4, i32 30, i32 63)

ST_24: tmp_26 [1/1] 0.00ns
:8  %tmp_26 = zext i34 %tmp_12 to i64

ST_24: tmp_13 [1/1] 1.37ns
:9  %tmp_13 = xor i64 %tmp_26, %mt_load_4


 <State 25>: 6.08ns
ST_25: tmp_14 [6/6] 6.08ns
:10  %tmp_14 = mul i64 %tmp_13, 1566083941


 <State 26>: 6.08ns
ST_26: tmp_14 [5/6] 6.08ns
:10  %tmp_14 = mul i64 %tmp_13, 1566083941


 <State 27>: 6.08ns
ST_27: tmp_14 [4/6] 6.08ns
:10  %tmp_14 = mul i64 %tmp_13, 1566083941


 <State 28>: 6.08ns
ST_28: tmp_14 [3/6] 6.08ns
:10  %tmp_14 = mul i64 %tmp_13, 1566083941


 <State 29>: 6.08ns
ST_29: tmp_2 [1/1] 0.00ns
:0  %tmp_2 = sext i32 %i_2 to i64

ST_29: mt_addr_3 [1/1] 0.00ns
:1  %mt_addr_3 = getelementptr inbounds [624 x i64]* @mt, i64 0, i64 %tmp_2

ST_29: mt_load_3 [2/2] 2.39ns
:2  %mt_load_3 = load i64* %mt_addr_3, align 8

ST_29: tmp_14 [2/6] 6.08ns
:10  %tmp_14 = mul i64 %tmp_13, 1566083941


 <State 30>: 7.45ns
ST_30: mt_load_3 [1/2] 2.39ns
:2  %mt_load_3 = load i64* %mt_addr_3, align 8

ST_30: tmp_14 [1/6] 6.08ns
:10  %tmp_14 = mul i64 %tmp_13, 1566083941

ST_30: tmp_15 [1/1] 1.37ns
:11  %tmp_15 = xor i64 %tmp_14, %mt_load_3

ST_30: tmp_27 [1/1] 0.00ns
:12  %tmp_27 = trunc i64 %tmp_15 to i32


 <State 31>: 6.53ns
ST_31: tmp_16_cast [1/1] 2.44ns
:13  %tmp_16_cast = sub i32 %tmp_27, %i_2

ST_31: tmp_17_cast [1/1] 0.00ns
:14  %tmp_17_cast = zext i32 %tmp_16_cast to i64

ST_31: stg_145 [1/1] 2.39ns
:15  store i64 %tmp_17_cast, i64* %mt_addr_3, align 8

ST_31: i_5 [1/1] 2.44ns
:16  %i_5 = add nsw i32 %i_2, 1

ST_31: tmp_22 [1/1] 2.52ns
:17  %tmp_22 = icmp sgt i32 %i_5, 623

ST_31: stg_148 [1/1] 1.57ns
:18  br i1 %tmp_22, label %5, label %._crit_edge1


 <State 32>: 2.39ns
ST_32: mt_load_5 [2/2] 2.39ns
:0  %mt_load_5 = load i64* getelementptr inbounds ([624 x i64]* @mt, i64 0, i64 623), align 8


 <State 33>: 4.78ns
ST_33: mt_load_5 [1/2] 2.39ns
:0  %mt_load_5 = load i64* getelementptr inbounds ([624 x i64]* @mt, i64 0, i64 623), align 8

ST_33: stg_151 [1/1] 2.39ns
:1  store i64 %mt_load_5, i64* getelementptr inbounds ([624 x i64]* @mt, i64 0, i64 0), align 16

ST_33: stg_152 [1/1] 1.57ns
:2  br label %._crit_edge1

ST_33: i_3 [1/1] 0.00ns
._crit_edge1:0  %i_3 = phi i32 [ 1, %5 ], [ %i_5, %4 ]

ST_33: k_3 [1/1] 1.84ns
._crit_edge1:1  %k_3 = add i10 %k_1, -1

ST_33: stg_155 [1/1] 0.00ns
._crit_edge1:2  br label %.preheader



============================================================
+ Verbose Summary: Binding
============================================================
N/A
* FSMD analyzer results:
  - Output states:
  - Chain level:
	State 1
	State 2
	State 3
	State 4
	State 5
	State 6
	State 7
	State 8
	State 9
	State 10
	State 11
	State 12
	State 13
	State 14
	State 15
	State 16
	State 17
	State 18
	State 19
	State 20
	State 21
	State 22
	State 23
	State 24
	State 25
	State 26
	State 27
	State 28
	State 29
	State 30
	State 31
	State 32
	State 33


============================================================
+ Verbose Summary: Datapath Resource usage 
============================================================
N/A
